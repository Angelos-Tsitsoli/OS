Τσιτσόλη Άγγελος sdi2000200

Εξήγηση αρχικά της μητρικής διεργασίας.
Γενικά χρησιμοποιώ 

Αρχείο parent.c :
Αρχικά στην main δίνουμε ως ορίσματα τον αριθμό των τμημάτων που θα χωριστεί το text αρχείο , τον αριθμό των παιδιών  και τον αριθμό των αιτήσεων που θα κάνει κάθε παιδί .Με τον δείκτη file_open θα δείχνουμε ουσιαστικά στο αρχείο με το κείμενο όπου τον δείκτη αυτόν  θα τον χρησιμοποιήσουμε για το διάβασμα του αρχείου με το κείμενο.
Μέσω της srand βάζουμε ένα seed προκειμένου τυχόν rand χρησιμοποιήσουμε,  να βγάζουν διαφορετικά αποτελέσματα.
Η μεταβλητή segments θα δεχεται τον αριθμό των τμημάτων του κειμένου τον οποιο τον δίνουμε απο την γραμμή εντολών  ως πρώτο όρισμα.
Η μεταβλητή lines_of_every_segments θα αναφέρεται στις γραμμές που θα έχει κάθε τμήμα .
Η μεταβλητή other_lines αναφέρεται στις γραμμές που περισσεύουν στο τέλος του αρχείου , τις οποίες και θα τοποθετήσουμε στο τελευταίο τμήμα μαζί με αυτές που έχει . Ουσιαστικά κάθε τμήμα θα έχει έναν ορισμένο αριθμό απο γραμμές απλώς μερικές φορές υπάρχουν και γραμμές που περισσεύουν , αυτές θα τις τοποθετήσουμε στο τελευταίο segment μαζί με τις ορισμένες γραμμές που θα έχει το τελευταίο τμήμα , όπως και τα άλλα τμήματα.
Μέσω της fopen ανοίγουμε το αρχείο text.txt μέσω της εντολής r.
Η μεταβλητή maxcharacters χρησιμοποιείται για να κρατάμε τον μέγιστο αριθμό χαρακτήρων που μπορεί να έχει μία γραμμή σε κάποιο τμήμα.
Η μεταβλητή iterator_through_lines θα χρησιμοποιηθεί για να διασχίζουμε τις γραμμές προκειμένου να βρούμε το μέγιστο αριθμό χαρακτήρων που μπορεί να έχει μια γραμμή .
Η μεταβλητή count χρησιμοποιείται αργότερα για την διάσχιση γραμμών ενός τμήματος προκειμένου να βρούμε το τμήμα που θέλουμε να βάλουμε στην διαμοιραζόμενη μνήμη απο το αρχείο .Η οποία μάλιστα αρχικοποείται με 1 καθώς τα τμήματα ξεκινάνε απο το 1 η τμηματοποίηση του αρχείου.
Η μεταβλητή  character θα διαβάζει ουσιαστικά απο το αρχείο κάθε χαρακτήρα.
Η μεταβλητή number_of_children θα είναι ο αριθμός απο παιδιά που θα δώσουμε απο την γραμμή εντολών .
Η μεταβλητή requests θα πάρει ως τιμή τον αριθμό των αιτήσεων που ζητάει κάθε παιδί και θα το παίρνει ως όρισμα.
Η μεταβλητή counter θα μετράει τον αριθμό των γραμμών τους αρχείου (ξεκινάει με την τιμή 1 διότι η τμηματοποίηση μας ξεκινάει απο το 1 ).

Η while αυτό που θα κάνει είναι να διατρέξει όλο το αρχείο προκειμένου να μετρήσουμε πόσες γραμμές έχει το αρχείο.Ομοίως να βρούμε για τις γραμμές το μέγιστο αριθμό χαρακτήρων που μπορεί να έχει μια γραμμή .
Συγκεκριμένα μέσα στον βρόγχο η μεταβλητή character δέχεται όπως είπαμε κάθε φορά κάθε χαρακτήρα .Αυτό γίνεται προκειμένου κάθε φορά που βρίσκουμε τον χαρακτήρα αλλαγής γραμμής τότε αυτό σημαίνει ότι πρέπει να τη μετρήσουμε ως νέα γραμμή .Δηλαδή προκειμένου να βρούμε τον αριθμό των γραμμών κάθε φορά που βρίσκουμε το σύμβολο αλλαγής γραμμλής αυξλανουμε κατά τον μετρητη counter που έχουμε..
Οπότε σε περίπτωση που ο χαρακτήρας που εξετάζουμε δεν είναι το σύμβολο αλλαγής γραμμής τότε αυτό σημαίνει ότι βρισκόμαστε σε μια γραμμή και διασχίζουμε κάθε χαρακτήρα της , άρα αυξάνουμε την μεταβλητή  iterator_through_lines όσο δεν βρίσκουμε την μεταβλητή αλλαγής γραμμής.
Σε περίπτωση που ο χαρακτήρας που εξετάζουμε είναι η αλλαγή γραμμής , τότε κσαταλαβαίνουμε ότι τελείωσαν οι χαρακτήρες της γραμμής που εξετάζαμε και θα ότι θα ελέγξουμε αν ο αριθμός των χαρακτήρων που ελέγξαμε είναι μεγαλύτερος απο τον αριθμό των χαρακτήρων που είχαμ ως μέγιστο νωρίτερα.Οπότε θέτουμε ξανά τον iterator_through_lines ίσο με μηδέν . Εφόσον βρήκαμε χαρακτήρα αλλαγής γραμμής τότε αυξάνουμε τον counter κατά ένα προφανώς διότι διαβάσαμε μια γραμμή και πάμε σε νέα.΄
Στην συνέχεια με την fseek επιστρέφουμε πίσω στην αρχή του αρχείου.
Διαιρώντας τον αριθμό των γραμμών του αρχείου με τον αριθμό των τμημάτων βρίσκουμε τον αριθμό των γραμμών κάθε τμήματος και το τοποθετούμε στην μεταβλητή lines_of_every_segment.
Επίσης υπάρχει περίπτωση να έχουμε και άλλες γραμμές εκτός απο τις προκαθορισμένες κάθε τμήματος , οπότε τις βρίσκουμε και αυτές.
Ο πίνακας buffer2 θα δεσμευτεί κανονικά όπου μέσα σαυτόν θα βάλουμε το τμήμα που θέλουμε . Θα έχει μέγεθος ίσο με τον μέγιστο αριθμό τον χαρακτήρων που μπορεί να έχει μια γραμμή επι τις γραμμές κάθε τμήματος προσθέτωντας και τις υπόλοιπες που μπορεί να έχει το τελευταίο τμήμα . Ουσαιστικά αυτό γίνεται έτσι ώστε στην χειρότερη περίπτωση που ένα τμήμα έχει σε όλες του τις γραμμές μέγιστο αριθμό χαρακτήρων και έχει και άλλες γραμμές εκτός απο τις καθορισμένες κάθε τμήματος.

Οισημαφόροι που χρησιμοποιούνται είναι unnamed semaphores και χρησιμοποιείται system V shared memory.
Έπειτα δημιουργούμε ορισμένους σημαφόρους.
Οι σημαφόροι αίτησης req_sem , απάντησης an_sem , και ο σημαφόρος για την είσοδο στο critical section critical_sem δημιουργούμνται με τον εξής τρόπο : καλούμε την συνάρτηση shmget προκειμένου να δεσμεύσουμε χώρο για τον σημαφόρο κάθε φορά (χρησιμοποιείται η μέθοδος που χρησιμοποιήθηκε στα αρχεία semtest_a.c) και έπειτα 'δίνουμε ' ουσιαστικά τον χώρο αυτό μέσω της συνάρτησης shmat , έπειτα μέσω της συνάρτησης sem_init αρχικοποιούμε τον σημαφόρο . Κάθε φορά ελέγχουμε και αν υπάρχει λάθος οπότε επιστρέφουμε ένα μύνημα και το κατάλληλο exit.Αυτή την μέθοδο την χρησιμοποιούμε για τους συγκεκριμένους σημαφόρους.Προφανώς οι σημαφόροι διαμοιράζονται . Οι σημαφόροι req_sem και an_sem αρχικοποιούνται με μηδέν ενώ ο critical sem αρχιοκοποιείται με 1.

Ο σημαφόρος req_sem δημιουργείται για να χρησιμοποιηθεί στην επικοινωνία του πατέρα με το παιδί .Ουσιαστικά ο σημαφόρος αυτός αρχικοποιείται με μηδέν έτσι ώστε ο πατέρας αρχικά να προσπαθεί να τον κατεβάσει (χωρίς να μπορεί προφανώς) μέχρι να τον ανεβάσει πρώτα ένα παιδί και έπειτα θα μπορέσει να τον κατεβάσει .Μαυτόν τον τρόπο ο πατέρας ουισαστικά περιμένει για μια αίτηση να του γίνει.

Ο σημαφόρος an_sem δημιουργείται για να επικοινωνήσει ο πατέρας με το παιδί δηλαδή. Το παιδί προσπαθέι να τον κατεβάσει χωρίς να μπορεί διότι είναι ήδη μηδέν οπότε το παιδί στο σημείο εκείνο θα περιμένει μέχρι κάποιος να τον ανεβάσει ώστε να καταφέρει να τον κατεβάσει . Οπότε ο πατέρας όταν δώσει στην διαμοιραζόμενη μνήμη το τμήμα που ζητήθηκε τότε θα ανεβάσει τον σημαφόρο an_sem ώστε να μπορέσει το παιδί να συνεχίσει.

Ο σημαφόρος read_sem χρησιμοποιείται για να μπορούμε να ανεβάζουμε και να κατεβάζουμε τον αριθμό των διεργασιών όλων των παιδιών συνολικά το*application.  

Δημιουργούμε ένα πίνακα απο σημαφόρους ο οποίος θα λέγεται mutex_array οσιαστικά ο κάθε σημαφόρος του πίνακα θα αντιστοιχεί σε κάθε ένα απο τα τμήματα του αρχείου και θα χρησιμοποιηθεί προκειμένου ένας αναγνώστης να μπορέσει να ανεβάσει τον αριθμό των αναγνωστών στο συγκεκριμένο τμήμα . Συγκεκριμένα ο πίνακας αυτών των σημαφόρων δημιουργείται για τον λόγο του ότι σε αντίθεση πχ με το αν είχαμε μόνο έναν τώρα δεν μπαίνουν στην ουρά παιδιά που έχουν το segment που θέλουν ήδη .

Έχουμε επίσης έναν πίνακα read array ο οποίος θα διαθέτει το πλήθος των αναγνωστών στο τμήμα που εξετάζεται. Μέσα στον οποίο θα γίνονται αυξήσεις και μειώσεις .

Δημιουργούμε ένα πίνακα buffer στην διαμοιραζόμενη μνήμη , στον οποίο θα βάζουμε το τμήμα που ζητάει κάθε φορα ένα παιδί ακι απο το οποίο θα πάρει μια γραμμή.

Η μεταβλητή seg θα αποτελεί το τμήμα που θα δεί ο πατέρας ότι πρέπει να εισάγει στο buffer κάθε φορά .

Δημιουργούμε έναν πίνακα τύπου pid_t με όνομα pids στον οποίο θα μπούν τα παιδιά.
Η μεταβλητή flag χρησιμοποιείται όταν βρεθεί το τμήμα που θέλουμε για να γεμίσουμε τον πίνακα με τις γραμμές του τμήματος.
Μέσω της μεταβλητής iterate κάνουμε αποθήκευση των χαρακτήρων στον πίνακα buffer2.
Η μεταβλητή stop χρησιμοποιείται για να σταμτήσουμε την εισαγωγή χαρακτήρων στον πίνακα buffer2.
H μεταβλητή the_segment_we_want θα διαθέτει το τμήμα που θέλουμε και μέσω της οποίας ο πατέρας θα βρεί το τμήμα που θέλει το παιδί.
Η μεταβλητή iterator_holder_new και η μεταβλητή iterator_holder_old θα χρησιμοποιηθούν προκειμένου να εισάγονται κάθε φορά οι σωστοί χαρακτήρες απο τιε γραμμλες ενός τμήματος και να μην μένουν απο προηγούμενα τμήματα χαρσκτήρες. Θα εξηγηθεί και καλύτερα στην συνέχεια.

Με ένα for βρόγχο θα δημιουργηθούν τόσα παιδιά , όσα ο αριθμός που δώσουμε απο την γραμμή εντολών στην αρχή.Τα παιδιά θα δημιουργηθούν με την συνάρτηση fork και κάθε φορά που καλείται η συνάρτηση αυτή η διεύθυνση ππυ επιστρέφεται δίνεται στον πίνακα pids για να 'διατηρήσουμε' ουσιαστικά τα παιδιά.Σε περίπτωση που η διεύθυνση που επιστραφεί όταν καλεσθεί η συνάρτηση fork είναι ίση με μηδέν τότε αναφερόμαστε σε ένα απο τα παιδιά που δημιουργούνται και θα καλεσθεί γιαυτό η συνάρτηση child.

Μετά την δημιουργία των παιδιών και ουσιαστικά του βρόγχου που είναι υπεύθυνος γιαυτό , ακολουθεί ένας άλλος βρόγχος προκειμένου ο πατέρας να εκτελέσει ορισμένες ενέργειες ανάλογα με τα αιτήματα των παιδιών του .
Συγκεκριμένα ο πατέρας περιμένει για κάποια αίτηση απο κάποιο παιδί , αυτό γίνεται μέσω της προσπάθειας του πατέρα να κατεβάσει τον σημαφόρο req_sem ο οποίος επιτηδευμένα αρχικοποιείται με μηδέν .Ουσιαστικά ο πατέρας δεν μπορεί να κατεβάσει τον σημαφόρο και περιμένει έτσι μέχρι κάποιο παιδί να κάνει μία αίτηση,  να ανεβάσει δηλαδή τον σημαφόρο αυτό της αίτησης προκειμένου γίνει έτσι το σήμα στον πατέρα ότι υπάρχει ένα αίτημα για τμήμα το οποίο δεν υπάρχει ήδη στην διαμοιραζόμενη περιοχή. 
Επομένως με μια fseek επιστρέφουμε στην αρχή του αρχείου. Αυτό γίνεται για να ψάξουμε το αρχείο μέχρι να βρούμε και το συγκεκριμένο τμήμα για το οποίο έγινε αίτηση .Δίνουμε στην μεταβλητή the_segment_we_want το τμήμα που θέλουμε να ψάξουμε και έπειτα ψάχνουμε στο αρχείο με το κείμενο για το τμήμα.Συγκεκριμένα μέσα στην while αν το τμήμα που θέλουμε είναι το τελευταίο τμήμα τότε θα ψάξουμε το τμήμα στο αρχείο μέχρι που κάποια στιγμή θα ισχύει ότι count/lines_of_every_segment==the_segment_we_want δηλαδή ότι βρήκαμε το τμήμα που θέλουμε και Εφόσον flag=0 θα αυξήσουμε το flag κατά ένα για να πούμε ουσιαστικά ότι βρήκαμε το παιδί και ότι απο εδω και μέχρι ένα σημείο να δωθούν οι γραμμές στο buffer2 το σημείο στοπ θα είναι το σημείο που θα φτάσουμε όταν συμπληρωθούν οι γραμμές που έχουν κάθε τμήμα , ωστόσο γιαυτό και αρχικά ελέγχουμε αν είναι το τελευταίο τμήμα διότι αν είναι τότε το στοπ για εμάς θα είναι όταν οι γραμμές φτάσουν τις γραμμές κάθε τμήματος συν μερικές ακόμα , αλλιώς αν δεν θέλουμε το τελευταίο τμήμα και θέλουμε κάποιο άλλο θα θέλουμε ως σημείο στοπ τις γραμμές που πρέπει να συμπληρωθούν απλά για το τμήμα όπως και στα υπόλοιπα.
Οπότε γίνεται έλεγχος αν το flag είναι ίσο με 1 και αν το count το οποίο συνεχίζει έχει φτάσει τον αριθμό στοπ πχ για παράδειγμα έστω αρχείο με 1000 γραμμές , 10 τμήματα και , 100 γραμμές το κα΄θενα και θέλουμε το τμήμα 2 το count θα φτάσει στο 200 και έπειτα θα σταματήσουμε στο 300 όσον αφορά τις γραμμές , αυτό σε περίπτωση που θέλουμε τμήμα διαφορετικό απο το τελευταίο , αν θέλαμε το τελευταίο τότε θα προσθέταμε και μερικές ακόμα γραμμές ώστε να σταματήσει το count και γενικότερα η εισαγωγή χαρακτήρων στον πίνακα.
Οπότε όταν το count φτάσει το stop θα σταματήσει.Ωστόσο θα δωθεί και η τιμή του iterate στην μεταβλητή iterator_holder_new.Γενικότερα οι μεταβλητές iterator_holder_new και iterator_holder_old χρησιμοποιούνται για να μην μείνει κάποιος χαρακτήρας απο προηγούμενο τμήμα στον πίνακα buffer2.Συγκεκριμένα έστω ότι ζητείται το τμήμα 2 το οποίο και βάζουμε μέσα στο buffer2 έπειτα ωστόσο μας ζητείται το τμήμα 3 το οποίο έχει λιγότερους χαρακτήρες απο το τμήμα 2 άρα μερικοί χαρακτήρες μένουν μέσα στον πίνακα buffer2 .Οπότε κάθε φορά στην μεταβλητή iterator_holder_old θα κρατάμε την τελευταία θέση που βάζουμε χαρακτήρα στο buffer όταν του βάζουμε ένα τμήμα και κάθε φορά που βάζουμε ένα καινούργιο τμήμα συγκρίνουμε την ελευταία θέση του buffer2 που μπήκε κάτι με την τελευταία θέση που μπαίνει στο καινούργιο τμήμα κάποιος χαρακτήρας , σε περίπτωση που η τελευταία θέση που βάλαμε κάτι στο buffer στο προηγούμενο τμήμα έχει μικρότερο απο την νέα τελευταία θέση που βάλαμε κάτι στον πίνακα buffer2 θα καλύψουμε το κένό αυτό με τους χαρακτήρες \0 οπότε κάθε φορά ανανεώνουμε τις μεταβλητές iterator_holder_old και iterator_holder_new και τις συγκρίνουμε αργότερα. 
Επίσης χρησιμοποιούμε και  else όπου κάνει την ίδια δουλειά για τμήμα που δεν είναι το τελευταίο όπως είπαμε (ώστε να βάλει τις γραμμές του).
Ακόμα ανεβάζουμε τον δείκτη στην αρχή του αρχείου όπως και νωρίτερα ώστε για να μπορούμε να βρούμε και κάποιο επόμενο τμήμα.
Τέλος ανεβάζουμε τον σημαφόρο απάντησης an_sem ώστε να μπορεί το παιδί στην συνέχεια να διαβάσει αυτό που έγραψε ο γονέας.
///////////////////////////////////////////////////
Στο τέλος του αρχείου πατέρα κάνουμε απαραίτητες καταστροφές και αποδεσμεύσεις.


Αρχείο child:
Όπως ειπώθηκε και νωρίτερα το παιδί θα κληθεί εφόσον η fork επιστρέψει μηδέν και μάλιστα θα δωθούν στο παιδί ως ορίσματα ότι δημιουργήσαμε στην διαμοιραζόμενη μνήμη καθώς και πληροφορίες όπως  μια μεταβλητή που λέει ποιο παιδί έκανε κλήση της συνάρτησης int inte, αριθμό γραμμών int lines , αριθμό γραμμών που περισσεύουν other_lines , μέγιστο αριθμό χαρακτήρων που μπορεί να έχει μία γραμμή int max_characters, αριθμό αιτήσεων num_of_requests, int segments αριθμό τμημάτων , int all_requests όλες οι αιτήσεις που θα πρέπει να γίνουν απο τα όλα τα παιδιά , int children αριθμός των παιδιών.
Ομοίως και εδώ ένας δείκτης σε αρχείο FILE* file_pointer θα χρησιμοποιηθεί για να δημιουργούμε αρχεία για τα παιδιά με πληροφορίες.
Η μεταβλητή count θα χρησιμοποιηθεί αργότερα για να βρίσκουμε τα τμήματα που θέλουμε εφόσον έχουν μπεί στο buffer της διαμοιραζόμενης μνήμης.
Ο δείκτης ptrbuf θα δείχνει στο buffer της διαμοιραζόμενης μνήμης.Στον δείκτη ptrbuf2 θα μπαίνει η γραμμή πυο ψάχναμε .
Η μεταβλητή random2 θα βρίσκει τυχαία μια γραμμή για να διαβάσει απο το τμήμα.
Η μεταβλητή next_random2 θα ελέγχει την πιθανότητα που αναφέρεται στην εκφώνηση , δηλαδή σε περίπτωση που διαθέτει πιθανότητα 0,7 τότε η νέα αίτηση θα αναφέρεται στο ίδιο τμήμα ενώ σε περίπτωση που έχει 0,3 η νέα αίτηση θα αναφέρεται σε νέο τμήμα.
Ο πίνακας array θα δέχεται τους χαρακτήρες που θα προκύψουν όταν μετατρέψουμε τους αριθμούς του χρόνου που κάνει κάθε παιδί να υποβάλλει μία αίτηση εώς την στιγμή της απάντησης που θα πάρει .Ουσιαστικά τα μετατρέπουμε σε χαρακτήρες για να χρησιμοποιήσουμε την συνάρτησησ sprintf ώστε να μεταφέρουμε τις πληροφορίες αυτές σε ένα νέο αρχείο που θα λέγεται text2.txt.
Ομοίως το array2 θα κάνει το ίδο θα πάρει τους χαρακτήρες για το τμήμα και την γραμμή που θέλει.
Η μεταβλητή beginning θα πάρει την τιμή για το χρόνο υποβολής αιτήματος.
Ημ μεταβλητή finishing θα πάρει την τιμή για για το χρόνο απάντησης στο αίτημα.
Η μεταβλητή iterator θα χρησιμοποιηθεί για προσπέλαση όπως και η iterator2.
Η μεταβλητή requests θα παίρνει το τμήμα του οποίου θέλει την γραμμή το παιδί χρησιμοποιώντας την rand με κάτω όριο και πάνω όριο πχ αν έχουμε 10 τμήματα τότε θα έχουμε κάτω όριο 1 και πάνω όριο το 9 .

Με μια for loop το παιδί ουσιαστικά θα κάνει τις αιτήσεις που θέλει.
Σε περίπτωση που το τμήμα που θέλουμε είναι το τελευταίο τότε το πάνω όριο για την τυχαία τιμή θα είναι το άθροισμα των γραμμών που μπορεί να έχει ένα τμήμα και των γραμμών που περισσεύουν, αλλιώς το πάνω όριο θα μόνο ο αριθμός των γραμμών που μπορεί να έχει ένα τμήμα.

Στην συνέχεια γίνονται τα εξής :

Κατεβάζουμε τον σημαφόρο read_child προκειμένου να αυξήσουμε κατά ένα την μεταβλητή *application προκειμένου να δείξουμε ότι μειώθηκαν οι συνολικές διεργασίες όλων των παιδιών συνολικά κατά μία.
Μόλις ανεβάσουμε την τιμή της μεταβλητής ανεβάζομε και τον σημαφόρο .
Χρησιμοποίησα σημαφόρο για την διαδικασία αυτή ώστε να μπορεί να γίνει κάποια στιγμή αποκλειστικά απο ένα παιδί και να μην μπεί και κάποιο άλλο και αυξήσει να γίνει δηλαδή με μια σειρά.
Αυτή η διαδικασία για την αύξηση του *application θα γίνει προκειμ΄λενου να δωθεί ένα όριο στον πατέρα προκειμένου να μπορεί κάποια στιγμή να σταματήσει να περιμένει για αιτήματα απο παιδιά.

Έπειτα κατεβάζουμε τον σημαφόρο &mtex[requests] για το τμήμα που ζητάει το παιδί και αυξάνει τον αριθμό των αναγνωστών στο συγκεκριμένο τμήμα
Αν είναι ο πρώτος αναγνώστης τότε να δώσει στην εμταβλητή seg το τμήμα που θέλουμε να ζητηθεί καθώςο πατέρας αυτό θα δεί προκειμένου να δώσει ένα τμήμα .
Έπειτα ξεκινάμε την μέτρηση του χρόμου για την υποβολή του αιτήματος που θα δωθει στην μεταβλητή beginning.
Ανεβάζουμε τον σημαφόρο αιτήματος άραο πατέρας καταλαβαίνει ότι θα πρέπει να δώσει κάποιο τμήμα.
Έπειτα το παιδί περιμένει τον πατέρα να ανεβάσει τον σημαφόρο απάντησης για να τον κατεβάσει .Ουσιαστικά μαυτόν τον τρόπο το παιδί προσπαθώντας να κατεβάσει τον σημαφόρο απάντησης ενώ είναι ήδη μηδέν θα μπλοκαριστεί μέχρι ο πατέρας να τελειώσει την διαδικασία γραψίματος , δηλαδή αυτό που επιτυγχάνεται είναι ο πατέρας να μπαίνει στο cfritical section του ανενόχλητος , να βγαίνει και έπειτα το παιδί να μπορέι να διαβάσει την γραμμή που θέλει , δεν βρίσκονται και οι δύο δηλαδή στο critical section τους.
Οπότε το παιδί θα κατεβάσει τον σημαφόρο απάντησης άρα θα μπορέσει να κατεβάσει και τον σημαφόρο critical sem επειδή είναι ο πρώτος αναγνώστης ώστε και οι υπόλοιποι αναγνώστε τους τμήματος αυτού να μπορούν να διαβάσουν ανενόχλητοι .
Ανεβάζει έπειτα τον σημαφόρο mtex[requests] για το συγκεκριμένο τμήμα ώστε να μπορούν να μπούν και άλλοι ανγνώστες και να αυξήσουν τον αριθμό των αναγνωστών.

Στην συνέχεια ακολουθεί η διαδικασία κατά την οποία ένας αναγνώστης θα βρεί την γραμμή που θέλει στο τμήμα που έχει φορτωθεί.
Δηλαδή μέσω της μεταβλητής count θα μετράμε τις γραμμές του τμήματος μέχρι να βρούμε την γραμμή που θέλουμε (αυτή που θα πεί η μεταβλητή random2) .Η διαδικασία αυτή θα γίνει όπως και νωρίτερα θα μετάμε δηλαδή το σύμβολο αλλαγής γραμμής , απλώς θα ψάχνουμε στον πίνακα buffer που δείχνει το ptrbuf και όχι σε αρχείο.
Σε περίπτωση που βρούμε την γραμμή που θέλουμε τότε την βάζουμε στoν πίνακα ptrbuf2 αλλιώς αν η γραμμή που βρήκαμε είναι κενή τότε απλά βάζουμε το γράμμα n όπου αυτό βγαίνει απο την φράση new line.
Έπειτα μέσω της sprintf μετατρέπουμε τους αριθμούς σε χαρακτήρες και τους βάζουμε σε ένα πίνακα ώστε να αποτυπωθούν έπειτα με την συνάρτηση fputc η οποία εκτυπώνει στο νέο αρχείο ανά χαρακτήρα.

Καλώντας την usleep(20) προκαλείται μαι καθυστέρηση 20ms.



Tέλος κατεβάζουμε τον σημαφόρο &mtex[requests] προκειμένου να κατεβάσουμε κατά ένα τον αριθμό των αναγνωστών του συγκεκριμένου τμήματος.Αν ο αριθμός τω ναναγνωστών είναι ίσος με μηδέν δηλαδή δεν υπάρχει άλλος αναγνώστης ανεβάζουμε τον σημαφόρο για το critical section προκειμένου να είναι εφικτό στην συνέχεια αν θελήσει κάποιος να μπεί.

Μόλις τελειώσουμε με τα παραπάνω στο τέλος της for βρίσκουμε ένα τυχαίο αριθμό απο το 0 εώς το 9 αν ο αριθμός είναι μικρότερος απο τρία τότε να βρεί καινούργιο τμήμα απο το οποίο να ζητήσει γραμμή αλλιώς να παραμείνει το ίδιο.

Μετά την for ελεέγχουμε αν είμαστε στο τελευταίο παιδί όπου ανεβάζουμε και κατεβάζουμε τον σημαφόρο req_sem για να μην γίνει κάποιο επιπλέον κατέβασμα απο τον πατέρα .





